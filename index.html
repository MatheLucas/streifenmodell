<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Digitales Streifenmodell</title>
<style>
  /* Grundlegende Stile */
  *, *::before, *::after {
    box-sizing: border-box;
  }

  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #f0f2f5;
    color: #333;
  }

  header {
    background: #4A90E2;
    color: #fff;
    padding: 20px;
    text-align: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }

  nav {
    background: #fff;
    padding: 10px 20px;
    display: flex;
    gap: 20px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    justify-content: center;
  }

  nav a {
    text-decoration: none;
    color: #333;
    font-weight: bold;
    cursor: pointer;
    padding: 5px 10px;
    border-radius: 5px;
  }

  nav a:hover {
    background: #4A90E2;
    color: #fff;
  }

  nav a.active {
    background: #4A90E2;
    color: #fff;
  }

  main {
    padding: 20px;
    max-width: 1000px;
    margin: 0 auto;
  }

  .hidden { display: none; }

  h2 { text-align: center; }

  .equation-inputs {
    background: #fafafa;
    border: 1px solid #ccc;
    border-radius: 5px;
    padding: 10px;
    max-width: 300px;
    margin: 20px auto;
    text-align: center;
  }

  .equation-inputs input[type=text] {
    width: 200px;
    margin-bottom: 10px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 3px;
    text-align: center;
  }

  .equation-inputs button {
    background: #4A90E2;
    color: #fff;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
    margin-top: 5px;
  }

  .equation-inputs button:hover {
    background: #407bbf;
  }

  .feedback {
    margin-top: 10px;
    font-weight: bold;
    min-height: 20px;
    text-align: center;
  }

  .workspace {
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 5px;
    padding: 20px;
    margin-top: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    text-align: center;
  }

  .strip-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin-bottom: 20px;
  }

  .eq-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: center;
    width: 100%;
  }

  .strip-container {
    border: 1px solid #ccc; 
    background: #f9f9f9; 
    border-radius: 5px; 
    padding: 0; /* Entfernt Padding */
    min-height: 50px; 
    display: flex; 
    flex-wrap: nowrap; 
    overflow-x: auto;
    justify-content: center;
    position: relative; 
    width: 100%; /* Set to 100% to utilize available space */
    gap: 0; /* Entfernt Gap */
  }

  .segment {
    background: #aaa; 
    color: #000; 
    padding: 0 10px; 
    border-radius: 3px; 
    height: 40px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    cursor: grab; 
    user-select: none; 
    margin: 0;
    flex: 0 0 auto;
    transition: width 0.3s;
  }

  .segment.var {
    background: #4A90E2; 
    color: #fff;
  }

  /* Neue Klasse für negative Konstanten */
  .segment.negative {
    background: #E94E77; /* Beispielhafte Farbe für negative Segmente */
    color: #fff;
  }

  /* Neue Klasse für negative Variablen */
  .segment.negative-var {
    background: #D94E77; /* Beispielhafte Farbe für negative Variablen */
    color: #fff;
  }

  /* Neue Klasse für Null-Segmente */
  .segment.zero {
    background: #7F8C8D; /* Beispielhafte Farbe für Null-Segmente */
    color: #fff;
  }

  .manipulation, .solution-check {
    margin-top: 20px; 
    text-align: center;
  }

  .manipulation input[type=text] {
    width: 100px; 
    padding: 5px; 
    border: 1px solid #ccc; 
    border-radius: 3px; 
    text-align: center;
  }

  .manipulation button {
    background: #4A90E2; 
    color: #fff; 
    border: none; 
    padding: 5px 10px; 
    border-radius: 3px; 
    cursor: pointer; 
    margin-left: 10px;
  }

  .manipulation button:hover {
    background: #407bbf;
  }

  .solution-check input[type=text] {
    width: 50px; 
    padding: 5px; 
    border: 1px solid #ccc; 
    border-radius: 3px; 
    text-align: center; 
    margin: 0 5px;
  }

  footer {
    text-align: center; 
    padding: 20px; 
    margin-top: 20px; 
    background: #f0f0f0; 
    font-size: 0.9em; 
    color: #666;
  }

  .accordion-section {
    margin: 20px 0;
  }

  .accordion-header {
    background: #4A90E2; 
    color: #fff; 
    padding: 10px; 
    border-radius: 3px; 
    cursor: pointer; 
    margin-bottom: 5px; 
    font-weight: bold;
  }

  .accordion-content {
    background: #fff; 
    border: 1px solid #ccc; 
    border-radius: 3px; 
    padding: 10px; 
    display: none;
  }

  .exercise-list li {
    margin-bottom: 10px;
  }

  .exercise-list a {
    color: #4A90E2; 
    text-decoration: none; 
    font-weight: bold;
  }

  .exercise-list a:hover {
    text-decoration: underline;
  }

  /* Zusätzliche CSS-Anpassungen für bessere mobile Darstellung */
  @media (max-width: 600px) {
    .strip-container {
      flex-direction: row;
    }
    .segment {
      min-width: 40px;
    }
  }

  /* Stil für die aktuelle Gleichung */
  .current-equation {
    margin-bottom: 20px;
    display: none; /* Initial versteckt */
  }
  .current-equation p {
    font-size: 1.2em;
    font-weight: bold;
  }

  /* Stil für den Hinweis-Button */
  .hint-button {
    background: #4A90E2;
    color: #fff;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 10px;
    font-size: 1em;
  }

  .hint-button:hover {
    background: #407bbf;
  }
</style>
</head>
<body>
<header>
  <h1>Digitales Streifenmodell</h1>
</header>
<nav>
  <a data-tab="home" class="active">Home</a>
  <a data-tab="exercises">Übungen</a>
  <a data-tab="about">Über uns</a>
</nav>

<main>
  <section id="home" class="tab-content">
    <h2>Löse deine Gleichung</h2>
    <div class="equation-inputs">
      <p>Gib eine Gleichung ein (z.B. 2x+3=9):</p>
      <input type="text" id="eq1" placeholder="Gleichung 1"><br>
      <div id="eq2Container" class="hidden">
        <p>Zweite Gleichung (für zwei Variablen):</p>
        <input type="text" id="eq2" placeholder="Gleichung 2">
      </div>
      <button id="loadEquationBtn">Gleichung(en) übernehmen</button>
      <div class="feedback" id="equationFeedback"></div>
    </div>

    <div class="workspace">
      <h3>Visualisierung</h3>
      <!-- Hinweis-Button -->
      <button class="hint-button" id="hintButton">Hinweis</button>
      <!-- Anzeige der aktuellen Gleichung -->
      <div class="current-equation" id="currentEquationDiv">
        <h4>Aktuelle Gleichung:</h4>
        <p id="currentEquationText"></p>
      </div>
      <div class="strip-area" id="stripArea"></div>
      <div class="manipulation">
        <h4>Termumformungen (Addition/Subtraktion)</h4>
        <p>Trage z.B. "-3" oder "-x" ein, um -3 oder -x auf alle Gleichungen anzuwenden.</p>
        <input type="text" id="manipulationInput" placeholder="-3 oder -x">
        <button id="applyManipulationBtn">Anwenden</button>
        <div class="feedback" id="manipFeedback"></div>
      </div>

      <div class="solution-check">
        <h4>Prüfe deine Lösung</h4>
        <div id="varInputs"></div>
        <button id="checkSolutionBtn">Prüfen</button>
        <div class="feedback" id="solutionFeedback"></div>
      </div>
    </div>
  </section>

  <section id="exercises" class="tab-content hidden">
    <h2>Übungen</h2>
    <p>Klappe einen Bereich aus, um die Aufgaben anzuzeigen.</p>

    <!-- Anfänger (16 Aufgaben) -->
    <div class="accordion-section">
      <div class="accordion-header" data-target="anfContent">Anfänger (16 Aufgaben)</div>
      <div class="accordion-content" id="anfContent">
        <ul class="exercise-list">
          <li><a href="#" class="load-ex" data-eq="x+5=12">x + 5 = 12</a></li>
          <li><a href="#" class="load-ex" data-eq="2x=14">2x = 14</a></li>
          <li><a href="#" class="load-ex" data-eq="x-3=7">x - 3 = 7</a></li>
          <li><a href="#" class="load-ex" data-eq="x+8=15">x + 8 = 15</a></li>
          <li><a href="#" class="load-ex" data-eq="x-6=4">x - 6 = 4</a></li>
          <li><a href="#" class="load-ex" data-eq="x+2=10">x + 2 = 10</a></li>
          <li><a href="#" class="load-ex" data-eq="x-1=5">x - 1 = 5</a></li>
          <li><a href="#" class="load-ex" data-eq="x+4=9">x + 4 = 9</a></li>
          <li><a href="#" class="load-ex" data-eq="x-2=6">x - 2 = 6</a></li>
          <li><a href="#" class="load-ex" data-eq="x+3=11">x + 3 = 11</a></li>
          <li><a href="#" class="load-ex" data-eq="x-4=2">x - 4 = 2</a></li>
          <li><a href="#" class="load-ex" data-eq="x+1=7">x + 1 = 7</a></li>
          <li><a href="#" class="load-ex" data-eq="x-5=0">x - 5 = 0</a></li>
          <li><a href="#" class="load-ex" data-eq="x+6=14">x + 6 = 14</a></li>
          <li><a href="#" class="load-ex" data-eq="x-7=-1">x - 7 = -1</a></li>
          <li><a href="#" class="load-ex" data-eq="x+7=13">x + 7 = 13</a></li>
        </ul>
      </div>
    </div>

    <!-- Fortgeschritten (30 Aufgaben) -->
    <div class="accordion-section">
      <div class="accordion-header" data-target="fortgContent">Fortgeschritten (30 Aufgaben)</div>
      <div class="accordion-content" id="fortgContent">
        <ul class="exercise-list">
          <li><a href="#" class="load-ex" data-eq="2(x+3)=14">2(x + 3) = 14</a></li>
          <li><a href="#" class="load-ex" data-eq="3x-5=10">3x - 5 = 10</a></li>
          <li><a href="#" class="load-ex" data-eq="4(x-2)=12">4(x - 2) = 12</a></li>
          <li><a href="#" class="load-ex" data-eq="5x+7=22">5x + 7 = 22</a></li>
          <li><a href="#" class="load-ex" data-eq="6x-4=20">6x - 4 = 20</a></li>
          <li><a href="#" class="load-ex" data-eq="7(x+1)=28">7(x + 1) = 28</a></li>
          <li><a href="#" class="load-ex" data-eq="8x+6=30">8x + 6 = 30</a></li>
          <li><a href="#" class="load-ex" data-eq="9(x-3)=18">9(x - 3) = 18</a></li>
          <li><a href="#" class="load-ex" data-eq="10x+5=35">10x + 5 = 35</a></li>
          <li><a href="#" class="load-ex" data-eq="2x+4=3x-2">2x + 4 = 3x - 2</a></li>
          <li><a href="#" class="load-ex" data-eq="3(x-1)=2x+5">3(x - 1) = 2x + 5</a></li>
          <li><a href="#" class="load-ex" data-eq="4x+3=2x+11">4x + 3 = 2x + 11</a></li>
          <li><a href="#" class="load-ex" data-eq="5(x+2)=3x+16">5(x + 2) = 3x + 16</a></li>
          <li><a href="#" class="load-ex" data-eq="6x-2=4x+10">6x - 2 = 4x + 10</a></li>
          <li><a href="#" class="load-ex" data-eq="7(x-4)=3x+8">7(x - 4) = 3x + 8</a></li>
          <li><a href="#" class="load-ex" data-eq="8x+5=4x+21">8x + 5 = 4x + 21</a></li>
          <li><a href="#" class="load-ex" data-eq="9(x+1)=5x+16">9(x + 1) = 5x + 16</a></li>
          <li><a href="#" class="load-ex" data-eq="10x-3=6x+9">10x - 3 = 6x + 9</a></li>
          <li><a href="#" class="load-ex" data-eq="2x+5=4x-3">2x + 5 = 4x - 3</a></li>
          <li><a href="#" class="load-ex" data-eq="3(x+2)=4x+1">3(x + 2) = 4x + 1</a></li>
          <li><a href="#" class="load-ex" data-eq="4x-6=2x+12">4x - 6 = 2x + 12</a></li>
          <li><a href="#" class="load-ex" data-eq="5(x-1)=3x+9">5(x - 1) = 3x + 9</a></li>
          <li><a href="#" class="load-ex" data-eq="6x+7=4x+19">6x + 7 = 4x + 19</a></li>
          <li><a href="#" class="load-ex" data-eq="7(x+2)=5x+14">7(x + 2) = 5x + 14</a></li>
          <li><a href="#" class="load-ex" data-eq="8x-4=6x+20">8x - 4 = 6x + 20</a></li>
          <li><a href="#" class="load-ex" data-eq="9(x-2)=7x+6">9(x - 2) = 7x + 6</a></li>
          <li><a href="#" class="load-ex" data-eq="10x+3=8x+23">10x + 3 = 8x + 23</a></li>
          <li><a href="#" class="load-ex" data-eq="2(x-1)=x+5">2(x - 1) = x + 5</a></li>
          <li><a href="#" class="load-ex" data-eq="3x+4=2x+10">3x + 4 = 2x + 10</a></li>
          <li><a href="#" class="load-ex" data-eq="4x-5=3x+7">4x - 5 = 3x + 7</a></li>
        </ul>
      </div>
    </div>

    <!-- Profi (10 Aufgaben, zwei Variablen) -->
    <div class="accordion-section">
      <div class="accordion-header" data-target="profiContent">Profi (10 Aufgaben, zwei Variablen)</div>
      <div class="accordion-content" id="profiContent">
        <ul class="exercise-list">
          <li><a href="#" class="load-ex2" data-eq1="x+y=10" data-eq2="x-y=2">x + y = 10 &amp; x - y = 2</a></li>
          <li><a href="#" class="load-ex2" data-eq1="2x+3y=12" data-eq2="x-y=3">2x + 3y = 12 &amp; x - y = 3</a></li>
          <li><a href="#" class="load-ex2" data-eq1="3x-y=5" data-eq2="2x+y=8">3x - y = 5 &amp; 2x + y = 8</a></li>
          <li><a href="#" class="load-ex2" data-eq1="x+2y=14" data-eq2="3x-y=5">x + 2y = 14 &amp; 3x - y = 5</a></li>
          <li><a href="#" class="load-ex2" data-eq1="4x+y=20" data-eq2="2x-y=4">4x + y = 20 &amp; 2x - y = 4</a></li>
          <li><a href="#" class="load-ex2" data-eq1="5x-2y=10" data-eq2="3x+y=15">5x - 2y = 10 &amp; 3x + y = 15</a></li>
          <li><a href="#" class="load-ex2" data-eq1="2x+y=8" data-eq2="x+3y=14">2x + y = 8 &amp; x + 3y = 14</a></li>
          <li><a href="#" class="load-ex2" data-eq1="3x+2y=18" data-eq2="x-y=1">3x + 2y = 18 &amp; x - y = 1</a></li>
          <li><a href="#" class="load-ex2" data-eq1="4x-y=16" data-eq2="2x+y=10">4x - y = 16 &amp; 2x + y = 10</a></li>
          <li><a href="#" class="load-ex2" data-eq1="5x+y=25" data-eq2="3x-2y=5">5x + y = 25 &amp; 3x - 2y = 5</a></li>
        </ul>
      </div>
    </div>
  </section>

  <section id="about" class="tab-content hidden">
    <h2>Über uns</h2>
    <p>Diese Website entstand im Rahmen einer Masterarbeit von Lucas Burmester.</p>
  </section>
</main>

<footer>
  <small>&copy; 2024 Digitales Streifenmodell - Alle Rechte vorbehalten.</small>
</footer>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // Token-Klasse zur Tokenisierung der Gleichungen
  class Token {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
  }

  // Hilfsfunktionen
  function uniqueVars(arr) { return [...new Set(arr)]; }

  function findVariables(eq) {
    const vars = eq.match(/[a-z]/gi);
    return vars ? Array.from(new Set(vars.map(v => v.toLowerCase()))) : [];
  }

  // Tokenizer-Funktion
  function tokenize(str) {
    // Automatisches Einfügen von '*' zwischen Zahlen und Variablen sowie zwischen Zahlen und '('
    str = str.replace(/(\d)([a-z])/gi, '$1*$2');
    str = str.replace(/(\d)\(/g, '$1*(');
    let tokens = [];
    let i = 0;
    while (i < str.length) {
      let ch = str[i];
      if (/[0-9]/.test(ch)) {
        let start = i;
        while (i < str.length && /[0-9.]/.test(str[i])) i++; // Erlaubt Punkte für Dezimalzahlen
        let numStr = str.slice(start, i);
        let numValue = parseFloat(numStr);
        if (isNaN(numValue)) {
          return { success: false, error: 'Ungültige Zahl: ' + numStr };
        }
        tokens.push(new Token('NUMBER', numValue));
        continue;
      }
      if (/[a-z]/i.test(ch)) {
        tokens.push(new Token('VAR', ch.toLowerCase()));
        i++;
        continue;
      }
      if (ch === '+' || ch === '-' || ch === '*' || ch === '(' || ch === ')' || ch === '=') {
        tokens.push(new Token(ch, ch));
        i++;
        continue;
      }
      return { success: false, error: 'Ungültiges Zeichen: ' + ch };
    }
    return { success: true, tokens: tokens };
  }

  // Parser-Funktionen
  function parseEquation(eq) {
    let tokRes = tokenize(eq);
    if (!tokRes.success) return tokRes;
    let tokens = tokRes.tokens;
    let eqIndex = tokens.findIndex(t => t.type === '=');
    if (eqIndex === -1) {
      return { success: false, error: 'Kein "=" gefunden.' };
    }
    let leftTokens = tokens.slice(0, eqIndex);
    let rightTokens = tokens.slice(eqIndex + 1);

    let leftParse = parseExp(leftTokens, 0);
    if (!leftParse.success) return leftParse;
    if (leftParse.nextPos !== leftTokens.length)
      return { success: false, error: 'Ungültiger Ausdruck links von "=".' };

    let rightParse = parseExp(rightTokens, 0);
    if (!rightParse.success) return rightParse;
    if (rightParse.nextPos !== rightTokens.length)
      return { success: false, error: 'Ungültiger Ausdruck rechts von "=".' };

    let vars = collectVars(leftParse.node).concat(collectVars(rightParse.node));
    vars = uniqueVars(vars);
    if (!isLinearExpr(leftParse.node) || !isLinearExpr(rightParse.node)) {
      return { success: false, error: 'Nur lineare Ausdrücke ohne Var*Var.' };
    }

    return { success: true, astLeft: leftParse.node, astRight: rightParse.node, vars: vars };
  }

  function parseExp(tokens, pos) {
    let leftRes = parseTerm(tokens, pos);
    if (!leftRes.success) return leftRes;
    let node = leftRes.node; let p = leftRes.nextPos;
    while (p < tokens.length && (tokens[p].type === '+' || tokens[p].type === '-')) {
      let op = tokens[p].type; p++;
      let rightRes = parseTerm(tokens, p);
      if (!rightRes.success) return rightRes;
      p = rightRes.nextPos;
      node = { type: 'op', op: op, left: node, right: rightRes.node };
    }
    return { success: true, node: node, nextPos: p };
  }

  function parseTerm(tokens, pos) {
    let leftRes = parseFactor(tokens, pos);
    if (!leftRes.success) return leftRes;
    let node = leftRes.node; let p = leftRes.nextPos;
    while (p < tokens.length && tokens[p].type === '*') {
      p++;
      let rightRes = parseFactor(tokens, p);
      if (!rightRes.success) return rightRes;
      p = rightRes.nextPos;
      node = { type: 'op', op: '*', left: node, right: rightRes.node };
    }
    return { success: true, node: node, nextPos: p };
  }

  function parseFactor(tokens, pos) {
    if (pos >= tokens.length) return { success: false, error: 'Unerwartetes Ende' };
    let t = tokens[pos];
    if (t.type === 'NUMBER') return { success: true, node: { type: 'num', value: t.value }, nextPos: pos + 1 };
    if (t.type === 'VAR') return { success: true, node: { type: 'var', name: t.value }, nextPos: pos + 1 };
    if (t.type === '(') {
      let inner = parseExp(tokens, pos + 1);
      if (!inner.success) return inner;
      if (inner.nextPos >= tokens.length || tokens[inner.nextPos].type !== ')')
        return { success: false, error: 'Fehlende schließende Klammer' };
      return { success: true, node: inner.node, nextPos: inner.nextPos + 1 };
    }
    return { success: false, error: 'Unerwartetes Token: ' + t.type };
  }

  function collectVars(node) {
    if (!node) return [];
    if (node.type === 'var') return [node.name];
    if (node.type === 'op') return collectVars(node.left).concat(collectVars(node.right));
    return [];
  }

  function isLinearExpr(node) {
    if (node.type === 'num' || node.type === 'var') return true;
    if (node.type === 'op') {
      if (node.op === '*') {
        let l = collectVars(node.left), r = collectVars(node.right);
        if (l.length > 0 && r.length > 0) return false;
      }
      return isLinearExpr(node.left) && isLinearExpr(node.right);
    }
    return true;
  }

  // Evaluierung der AST
  function evalAST(node, varValues) {
    if (node.type === 'num') return node.value;
    if (node.type === 'var') return varValues[node.name] || 0;
    if (node.type === 'op') {
      let L = evalAST(node.left, varValues);
      let R = evalAST(node.right, varValues);
      if (node.op === '+') return L + R;
      if (node.op === '-') return L - R;
      if (node.op === '*') return L * R;
    }
    return NaN;
  }

  // Hinzufügen der evalEq Funktion
  function evalEq(eqObj, varValues, vars) {
    let leftVal = evalAST(eqObj.astLeft, varValues);
    let rightVal = evalAST(eqObj.astRight, varValues);
    return leftVal - rightVal;
  }

  // Anpassung der sumSegments Funktion
  function sumSegments(segs) {
    return segs.reduce((acc, s) => acc + Math.abs(s.value || 0), 0);
  }

  // Hilfsfunktion zum Duplizieren von Segmenten
  function duplicateSegments(segs, multiplier) {
    let result = [];
    for (let i = 0; i < multiplier; i++) {
      for (let s of segs) {
        result.push({...s});
      }
    }
    return result;
  }

  // Erstellung der Expression Data
  function createExpressionData(astL, astR, vars, varVals) {
    let leftSeg = expandNode(astL, varVals);
    let rightSeg = expandNode(astR, varVals);
    let rightVal = sumSegments(rightSeg);
    let leftVal = sumSegments(leftSeg);
    return {
      left: { segments: leftSeg, total: leftVal },
      right: { segments: rightSeg, total: rightVal }
    };
  }

  // Erweiterte Funktion zum Sammeln und Kombinieren von Termen
  function collectAndCombineTerms(node) {
    let terms = { vars: {}, constants: 0 };
    function traverse(n) {
      if (!n) return;
      if (n.type === 'op') {
        if (n.op === '+') {
          traverse(n.left);
          traverse(n.right);
        } else if (n.op === '-') {
          traverse(n.left);
          traverseNegative(n.right);
        } else if (n.op === '*') {
          if (n.left.type === 'num' && n.right.type === 'var') {
            terms.vars[n.right.name] = (terms.vars[n.right.name] || 0) + n.left.value;
          } else if (n.right.type === 'num' && n.left.type === 'var') {
            terms.vars[n.left.name] = (terms.vars[n.left.name] || 0) + n.right.value;
          }
          // Neue Bedingung für num * num
          else if (n.left.type === 'num' && n.right.type === 'num') {
            terms.constants += n.left.value * n.right.value;
          } else {
            console.warn('Unsupported multiplication with complex expressions:', n.left.type, '*', n.right.type);
          }
        }
      } else if (n.type === 'num') {
        terms.constants += n.value;
      } else if (n.type === 'var') {
        terms.vars[n.name] = (terms.vars[n.name] || 0) + 1;
      }
    }

    function traverseNegative(n) {
      if (!n) return;
      if (n.type === 'op') {
        if (n.op === '+') {
          traverseNegative(n.left);
          traverseNegative(n.right);
        } else if (n.op === '-') {
          traverseNegative(n.left);
          traverse(n.right); // Subtrahieren eines Subtraktionsausdrucks
        } else if (n.op === '*') {
          if (n.left.type === 'num' && n.right.type === 'var') {
            terms.vars[n.right.name] = (terms.vars[n.right.name] || 0) - n.left.value;
          }
          // Neue Bedingung für num * num in traverseNegative
          else if (n.left.type === 'num' && n.right.type === 'num') {
            terms.constants -= n.left.value * n.right.value;
          } else if (n.right.type === 'num' && n.left.type === 'var') {
            terms.vars[n.left.name] = (terms.vars[n.left.name] || 0) - n.right.value;
          } else {
            console.warn('Unsupported multiplication with complex expressions:', n.left.type, '*', n.right.type);
          }
        }
      } else if (n.type === 'num') {
        terms.constants -= n.value;
      } else if (n.type === 'var') {
        terms.vars[n.name] = (terms.vars[n.name] || 0) - 1;
      }
    }

    traverse(node);
    return terms;
  }

  // Rebuild AST from combined terms
  function rebuildAST(terms) {
    let nodes = [];
    for (let varName in terms.vars) {
      let coeff = terms.vars[varName];
      if (coeff === 0) continue;
      if (coeff === 1) {
        nodes.push({ type: 'var', name: varName });
      } else {
        nodes.push({ type: 'op', op: '*', left: { type: 'num', value: coeff }, right: { type: 'var', name: varName } });
      }
    }
    if (Math.abs(terms.constants) > 1e-9) { // Verhindert Rundungsfehler
      nodes.push({ type: 'num', value: terms.constants });
    }

    if (nodes.length === 0) {
      return { type: 'num', value: 0 };
    }

    let ast = nodes[0];
    for (let i = 1; i < nodes.length; i++) {
      ast = { type: 'op', op: '+', left: ast, right: nodes[i] };
    }
    return ast;
  }

  // Funktion zur Vereinfachung der Gleichungen
  function simplifyEquation(eqObj) {
    const MAX_ITERATIONS = 20; // Erhöht, um mehr Komplexität zu handhaben
    let prevLeft = null;
    let prevRight = null;
    let iterations = 0;

    while ((JSON.stringify(eqObj.astLeft) !== JSON.stringify(prevLeft) || JSON.stringify(eqObj.astRight) !== JSON.stringify(prevRight)) && iterations < MAX_ITERATIONS) {
      prevLeft = JSON.stringify(eqObj.astLeft);
      prevRight = JSON.stringify(eqObj.astRight);
      // Vereinfachung des AST (Anwenden des Distributivgesetzes)
      eqObj.astLeft = simplifyAST(eqObj.astLeft);
      eqObj.astRight = simplifyAST(eqObj.astRight);
      // Kombinieren von Termen
      let combinedLeft = collectAndCombineTerms(eqObj.astLeft);
      let combinedRight = collectAndCombineTerms(eqObj.astRight);
      eqObj.astLeft = rebuildAST(combinedLeft);
      eqObj.astRight = rebuildAST(combinedRight);

      iterations++;
    }

    if (iterations === MAX_ITERATIONS) {
      console.warn('Maximale Anzahl von Vereinfachungsiterationen erreicht. Vereinfachung möglicherweise nicht vollständig.');
      manipFeedback.style.color = 'red';
      manipFeedback.textContent = 'Vereinfachung konnte nicht vollständig durchgeführt werden. Bitte überprüfen Sie Ihre Gleichung.';
    }

    return eqObj;
  }

  // Funktion zur Vereinfachung des AST (Anwenden des Distributivgesetzes)
  function simplifyAST(node) {
    if (node.type === 'op') {
      node.left = simplifyAST(node.left);
      node.right = simplifyAST(node.right);
      
      if (node.op === '*') {
        // Fall 1: Zahl * (a + b) oder Zahl * (a - b)
        if (node.left.type === 'num' && node.right.type === 'op' && (node.right.op === '+' || node.right.op === '-')) {
          // Distributivgesetz: a*(b+c) = a*b + a*c
          let newLeft = { type: 'op', op: '*', left: { type: 'num', value: node.left.value }, right: node.right.left };
          let newRight = { type: 'op', op: '*', left: { type: 'num', value: node.left.value }, right: node.right.right };
          return { type: 'op', op: node.right.op, left: newLeft, right: newRight };
        } 
        // Fall 2: (a + b) * Zahl oder (a - b) * Zahl
        else if (node.right.type === 'num' && node.left.type === 'op' && (node.left.op === '+' || node.left.op === '-')) {
          // Distributivgesetz: (a+b)*c = a*c + b*c
          let newLeft = { type: 'op', op: '*', left: node.left.left, right: { type: 'num', value: node.right.value } };
          let newRight = { type: 'op', op: '*', left: node.left.right, right: { type: 'num', value: node.right.value } };
          return { type: 'op', op: node.left.op, left: newLeft, right: newRight };
        }
      }
    }
    return node;
  }

  // Termumformung (Addition/Subtraktion)
  function applyManipulation(eqObj, manipulation) {
    if (manipulation.type === 'constant') {
      // Füge die Konstante zu beiden Seiten der Gleichung hinzu
      eqObj.astLeft = { type: 'op', op: '+', left: eqObj.astLeft, right: { type: 'num', value: manipulation.value } };
      eqObj.astRight = { type: 'op', op: '+', left: eqObj.astRight, right: { type: 'num', value: manipulation.value } };
    } else if (manipulation.type === 'variable') {
      // Füge das Variablelement zu beiden Seiten der Gleichung hinzu
      eqObj.astLeft = { type: 'op', op: '+', left: eqObj.astLeft, right: manipulation.term };
      eqObj.astRight = { type: 'op', op: '+', left: eqObj.astRight, right: manipulation.term };
    }
    // Vereinfachen der Gleichung
    simplifyEquation(eqObj);
  }

  // Evaluierung der Gleichungen mit benutzerdefinierten varValues
  function checkEquation(eqObj, varValues) {
    let leftVal = evalAST(eqObj.astLeft, varValues);
    let rightVal = evalAST(eqObj.astRight, varValues);
    return Math.abs(leftVal - rightVal) < 1e-6; // Erhöhte Toleranz für Dezimalzahlen
  }

  // Lösen der Gleichungen
  function solveOneVar(eqObj, vname) {
    let varVals0 = {};
    varVals0[vname] = 0;
    let Diff0 = evalEq(eqObj, varVals0, [vname]);

    let varVals1 = {};
    varVals1[vname] = 1;
    let Diff1 = evalEq(eqObj, varVals1, [vname]);

    let a = Diff1 - Diff0;
    let bMinusC = Diff0;
    let varVals = {};
    if (Math.abs(a) < 1e-14) {
      varVals[vname] = 3;
      return varVals;
    }
    varVals[vname] = -(bMinusC) / a;
    return varVals;
  }

  function getCoefficients(eqObj, vars) {
    if (vars.length === 1) {
      let Diff0 = evalEq(eqObj, { [vars[0]]: 0 }, vars);
      let Diff1x = evalEq(eqObj, { [vars[0]]: 1 }, vars);
      let a = (Diff1x - Diff0);
      let b = 0;
      let c = Diff0;
      return { a: a, b: b, c: c, vars: 1 };
    } else {
      let Diff00 = evalEq(eqObj, { [vars[0]]: 0, [vars[1]]: 0 }, vars);
      let Diff10 = evalEq(eqObj, { [vars[0]]: 1, [vars[1]]: 0 }, vars);
      let Diff01 = evalEq(eqObj, { [vars[0]]: 0, [vars[1]]: 1 }, vars);
      let a = (Diff10 - Diff00);
      let b = (Diff01 - Diff00);
      let c = Diff00;
      return { a: a, b: b, c: c, vars: 2 };
    }
  }

  function fallbackVars(vars) {
    let varVals = {};
    vars.forEach(v => varVals[v] = 3);
    return varVals;
  }

  function solveTwoVars(eqs, vars) {
    let co1 = getCoefficients(eqs[0], vars);
    let co2 = getCoefficients(eqs[1], vars);
    let a1 = co1.a; let b1 = co1.b; let c1 = co1.c;
    let a2 = co2.a; let b2 = co2.b; let c2 = co2.c;
    let D = a1 * b2 - a2 * b1;
    if (Math.abs(D) < 1e-14) return fallbackVars(vars);
    let x = (b2 * (-c1) - b1 * (-c2)) / D;
    let y = (a1 * (-c2) - a2 * (-c1)) / D;
    let varVals = {};
    varVals[vars[0]] = x;
    varVals[vars[1]] = y;
    return varVals;
  }

  function solveVars(parsedEquations, vars) {
    if (vars.length === 0) return fallbackVars(vars);
    if (vars.length === 1 && parsedEquations.length >= 1) {
      let val = solveOneVar(parsedEquations[0], vars[0]);
      for (let v in val) val[v] = Math.round(val[v] * 1000000) / 1000000; // Rundung
      return val;
    }
    if (vars.length === 2 && parsedEquations.length === 2) {
      let val = solveTwoVars(parsedEquations, vars);
      for (let v in val) val[v] = Math.round(val[v] * 1000000) / 1000000; // Rundung
      return val;
    }
    let val = fallbackVars(vars);
    for (let v in val) val[v] = Math.round(val[v] * 1000000) / 1000000;
    return val;
  }

  // Funktion zur Berechnung des Skalierungsfaktors
  function calculateScalingFactor() {
    const stripContainers = document.querySelectorAll('.strip-container');
    if (stripContainers.length === 0) {
      scalingFactor = 30; // default
      return;
    }

    // Find the maximum total across all sides
    let maxTotal = 0;
    expressionDatas.forEach(expr => {
      if (expr.left.total > maxTotal) maxTotal = expr.left.total;
      if (expr.right.total > maxTotal) maxTotal = expr.right.total;
    });

    if (maxTotal === 0) {
      scalingFactor = 30; // fallback
      return;
    }

    // Assume we want the maximum total to take up 80% of the container width
    // Get container width
    let containerWidth = stripContainers[0].clientWidth; // assuming all strip containers have same width
    let scaling = (containerWidth * 0.8) / maxTotal;

    // Clamp scalingFactor
    if (scaling < 10) scalingFactor = 10;
    else if (scaling > 60) scalingFactor = 60;
    else scalingFactor = scaling;
  }

  // Variablen und Gleichungen
  let parsedEquationsList = [];
  let variables = [];
  let expressionDatas = [];

  // DOM-Elemente
  const eq1Input = document.getElementById('eq1');
  const eq2Input = document.getElementById('eq2');
  const eq2ContainerEl = document.getElementById('eq2Container');
  const loadEquationBtn = document.getElementById('loadEquationBtn');
  const equationFeedback = document.getElementById('equationFeedback');
  const manipulationInput = document.getElementById('manipulationInput');
  const applyManipulationBtn = document.getElementById('applyManipulationBtn');
  const manipFeedback = document.getElementById('manipFeedback');
  const varInputsDiv = document.getElementById('varInputs');
  const checkSolutionBtn = document.getElementById('checkSolutionBtn');
  const solutionFeedback = document.getElementById('solutionFeedback');
  const stripArea = document.getElementById('stripArea');
  const currentEquationText = document.getElementById('currentEquationText'); // Element zur Anzeige der aktuellen Gleichung
  const currentEquationDiv = document.getElementById('currentEquationDiv'); // Container für die aktuelle Gleichung
  const hintButton = document.getElementById('hintButton'); // Hinweis-Button

  // Skalierungsfaktor und Funktion zur Berechnung
  let scalingFactor = 30; // Initialer Wert, wird später überschrieben

  // Strip-Container
  let eq1LeftStrip, eq1RightStrip, eq2LeftStrip, eq2RightStrip;
  let dragSegment = null; 
  let dragOverContainer = null;

  // Ereignislistener für eq1 Input
  eq1Input.addEventListener('input', () => {
    const eq = eq1Input.value;
    const v = findVariables(eq);
    if (v.length > 1) eq2ContainerEl.classList.remove('hidden');
    else eq2ContainerEl.classList.add('hidden');
  });

  // Ereignislistener für "Gleichung übernehmen" Button
  loadEquationBtn.addEventListener('click', () => {
    const eq1 = eq1Input.value.trim();
    const eq2 = eq2Input.value.trim();
    parsedEquationsList = [];

    if (eq1 === '') {
      equationFeedback.style.color = 'red';
      equationFeedback.textContent = 'Bitte gib mindestens eine Gleichung ein.';
      return;
    }

    let eq1Res = parseEquation(eq1);
    if (!eq1Res.success) {
      equationFeedback.style.color = 'red';
      equationFeedback.textContent = eq1Res.error;
      return;
    }
    // Vereinfachen des AST vor dem Speichern
    eq1Res.astLeft = simplifyAST(eq1Res.astLeft);
    eq1Res.astRight = simplifyAST(eq1Res.astRight);
    eq1Res = simplifyEquation(eq1Res);
    parsedEquationsList.push(eq1Res);

    let allVars = uniqueVars(eq1Res.vars);

    if (allVars.length > 1) {
      if (!eq2) {
        equationFeedback.style.color = 'red';
        equationFeedback.textContent = "Zwei Variablen erkannt! Bitte zweite Gleichung eingeben.";
        return;
      }
      let eq2Res = parseEquation(eq2);
      if (!eq2Res.success) {
        equationFeedback.style.color = 'red';
        equationFeedback.textContent = eq2Res.error;
        return;
      }
      // Vereinfachen des AST vor dem Speichern
      eq2Res.astLeft = simplifyAST(eq2Res.astLeft);
      eq2Res.astRight = simplifyAST(eq2Res.astRight);
      eq2Res = simplifyEquation(eq2Res);
      parsedEquationsList.push(eq2Res);
      for (let vv of eq2Res.vars) {
        if (!allVars.includes(vv)) allVars.push(vv);
      }
    }

    variables = allVars;
    let varVals = solveVars(parsedEquationsList, variables);
    expressionDatas = [];
    for (let eqObj of parsedEquationsList) {
      expressionDatas.push(createExpressionData(eqObj.astLeft, eqObj.astRight, variables, varVals));
    }

    // Berechnung des Skalierungsfaktors basierend auf der neuen Datenlage
    calculateScalingFactor();

    equationFeedback.style.color = 'green';
    equationFeedback.textContent = "Gleichung(en) übernommen.";

    setupStrips();
    updateStrips();

    // Erstellung der Eingabefelder für Variablen
    varInputsDiv.innerHTML = '';
    variables.forEach(v => {
      const inp = document.createElement('input');
      inp.type = 'text';
      inp.placeholder = v;
      inp.id = 'var_' + v;
      varInputsDiv.appendChild(document.createTextNode(v + " = "));
      varInputsDiv.appendChild(inp);
    });
    solutionFeedback.textContent = '';
    manipFeedback.textContent = '';

    // Aktualisiere die Anzeige der aktuellen Gleichung
    updateCurrentEquation();
  });

  // Ereignislistener für "Anwenden" Button (Termumformungen)
  applyManipulationBtn.addEventListener('click', () => {
    const manipulationInputStr = manipulationInput.value.trim();
    if (!manipulationInputStr) return;

    let manipulation = null;

    // Konvertieren von Kommas zu Punkten für korrekte Dezimalzahlen
    let cleanedInput = manipulationInputStr.replace(',', '.');

    // Prüfen, ob die Manipulation eine Zahl ist
    let num = parseFloat(cleanedInput);
    if (!isNaN(num)) {
      manipulation = { type: 'constant', value: num };
    } else {
      // Prüfen, ob die Manipulation ein Variablelement ist, z.B. "-x" oder "+y"
      let varMatch = cleanedInput.match(/^([+-]?)([a-z])$/i);
      if (varMatch) {
        let sign = varMatch[1];
        let varName = varMatch[2].toLowerCase();
        let coeff = 1;
        if (sign === '-') coeff = -1;
        else if (sign === '+') coeff = 1;
        manipulation = { 
          type: 'variable', 
          term: { 
            type: 'op', 
            op: '*', 
            left: { type: 'num', value: coeff }, 
            right: { type: 'var', name: varName } 
          } 
        };
      } else {
        manipFeedback.style.color = 'red';
        manipFeedback.textContent = 'Ungültige Manipulation. Bitte gib eine Zahl oder eine Variable ein (z.B. "-3" oder "-x").';
        return;
      }
    }

    // Wende die Termumformung auf jede Gleichung an
    parsedEquationsList.forEach(eqObj => {
      applyManipulation(eqObj, manipulation);
    });

    // Nach der Termumformung erneut die Variablen und Lösungen berechnen
    let varVals = solveVars(parsedEquationsList, variables);
    expressionDatas = [];
    for (let eqObj of parsedEquationsList) {
      expressionDatas.push(createExpressionData(eqObj.astLeft, eqObj.astRight, variables, varVals));
    }

    // Berechnung des Skalierungsfaktors basierend auf den aktualisierten Daten
    calculateScalingFactor();

    manipFeedback.style.color = 'green';
    manipFeedback.textContent = 'Operation angewendet.';
    updateStrips();

    // Aktualisiere die Anzeige der aktuellen Gleichung
    updateCurrentEquation();
  });

  // Ereignislistener für "Prüfen" Button
  checkSolutionBtn.addEventListener('click', () => {
    let varValues = {};
    for (let v of variables) {
      const inp = document.getElementById('var_' + v);
      let valStr = inp.value.trim().replace(',', '.'); // Konvertieren von Kommas zu Punkten
      const val = parseFloat(valStr);
      if (isNaN(val)) {
        solutionFeedback.style.color = 'red';
        solutionFeedback.textContent = 'Bitte gültige Zahl für ' + v + ' eingeben.';
        return;
      }
      varValues[v] = val;
    }

    let allCorrect = true;
    for (let eqObj of parsedEquationsList) {
      if (!checkEquation(eqObj, varValues)) {
        allCorrect = false;
        break;
      }
    }

    if (allCorrect) {
      solutionFeedback.style.color = 'green';
      solutionFeedback.textContent = 'Richtig!';
    } else {
      solutionFeedback.style.color = 'red';
      solutionFeedback.textContent = 'Falsch!';
    }
  });

  // Ereignislistener für Anfängeraufgaben
  document.querySelectorAll('.load-ex').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const eq = e.currentTarget.getAttribute('data-eq');
      document.querySelector('nav a[data-tab="home"]').click();
      eq1Input.value = eq;
      eq2Input.value = '';
      eq2ContainerEl.classList.add('hidden');
      equationFeedback.textContent = '';
      solutionFeedback.textContent = '';
      manipFeedback.textContent = '';
      varInputsDiv.innerHTML = '';
      loadEquationBtn.click();
    });
  });

  // Ereignislistener für Profiaufgaben
  document.querySelectorAll('.load-ex2').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const eq1 = e.currentTarget.getAttribute('data-eq1');
      const eq2 = e.currentTarget.getAttribute('data-eq2');
      document.querySelector('nav a[data-tab="home"]').click();
      eq1Input.value = eq1;
      eq2Input.value = eq2;
      eq2ContainerEl.classList.remove('hidden');
      equationFeedback.textContent = '';
      solutionFeedback.textContent = '';
      manipFeedback.textContent = '';
      varInputsDiv.innerHTML = '';
      loadEquationBtn.click();
    });
  });

  // Setup der Streifen-Container
  function setupStrips() {
    stripArea.innerHTML = '';
    if (parsedEquationsList.length === 1) {
      let eqCont = document.createElement('div');
      eqCont.classList.add('eq-container');

      eq1LeftStrip = document.createElement('div');
      eq1LeftStrip.classList.add('strip-container');

      eq1RightStrip = document.createElement('div');
      eq1RightStrip.classList.add('strip-container');

      eqCont.appendChild(eq1LeftStrip);
      eqCont.appendChild(eq1RightStrip);

      stripArea.appendChild(eqCont);
    } else {
      let eqCont1 = document.createElement('div');
      eqCont1.classList.add('eq-container');
      eq1LeftStrip = document.createElement('div');
      eq1LeftStrip.classList.add('strip-container');
      eq1RightStrip = document.createElement('div');
      eq1RightStrip.classList.add('strip-container');
      eqCont1.appendChild(eq1LeftStrip);
      eqCont1.appendChild(eq1RightStrip);

      let eqCont2 = document.createElement('div');
      eqCont2.classList.add('eq-container');
      eq2LeftStrip = document.createElement('div');
      eq2LeftStrip.classList.add('strip-container');
      eq2RightStrip = document.createElement('div');
      eq2RightStrip.classList.add('strip-container');
      eqCont2.appendChild(eq2LeftStrip);
      eqCont2.appendChild(eq2RightStrip);

      stripArea.appendChild(eqCont1);
      stripArea.appendChild(eqCont2);
    }
  }

  // Drag & Drop Funktionen
  function makeSegmentsDraggable(container) {
    container.querySelectorAll('.segment').forEach(seg => {
      seg.draggable = true;
      seg.addEventListener('dragstart', () => {
        dragSegment = seg;
        seg.style.opacity = '0.5';
      });
      seg.addEventListener('dragend', () => {
        dragSegment = null;
        seg.style.opacity = '1';
      });

      // Touch-Unterstützung
      seg.addEventListener('touchstart', (ev) => {
        dragSegment = seg;
        seg.style.opacity = '0.5';
        ev.preventDefault();
      }, { passive: false });

      seg.addEventListener('touchmove', (ev) => {
        if (dragSegment) {
          const touch = ev.touches[0];
          const elem = document.elementFromPoint(touch.clientX, touch.clientY);
          if (elem && elem.classList.contains('strip-container')) {
            dragOverContainer = elem;
          }
        }
      }, { passive: false });

      seg.addEventListener('touchend', (ev) => {
        if (dragSegment && dragOverContainer) {
          dragOverContainer.appendChild(dragSegment);
          // Aktualisiere die Gleichungen basierend auf der neuen Position
          updateEquationAfterDrag();
        }
        seg.style.opacity = '1';
        dragSegment = null;
        dragOverContainer = null;
        ev.preventDefault();
      }, { passive: false });
    });

    container.addEventListener('dragover', (ev) => {
      ev.preventDefault();
      dragOverContainer = container;
    });

    container.addEventListener('drop', (ev) => {
      ev.preventDefault();
      if (dragSegment && dragOverContainer === container) {
        container.appendChild(dragSegment);
        // Aktualisiere die Gleichungen basierend auf der neuen Position
        updateEquationAfterDrag();
      }
    });
  }

  // Funktion zur Aktualisierung der Gleichungen nach Drag & Drop
  function updateEquationAfterDrag() {
    // Hier können Sie die Position der Segmente analysieren und die Gleichungen entsprechend anpassen.
    // Dies ist eine komplexe Aufgabe und erfordert eine genaue Implementierung basierend auf der gewünschten Logik.
    // Für den Moment wird einfach die Visualisierung aktualisiert.

    // Re-evaluate varVals based on current arrangement
    let varVals = solveVars(parsedEquationsList, variables);
    expressionDatas = [];
    for (let eqObj of parsedEquationsList) {
      expressionDatas.push(createExpressionData(eqObj.astLeft, eqObj.astRight, variables, varVals));
    }

    // Berechnung des Skalierungsfaktors basierend auf den aktualisierten Daten
    calculateScalingFactor();

    updateStrips();
    updateCurrentEquation();
  }

  // Expandieren der AST-Knoten zu Segmenten
  function expandNode(node, varVals) {
    let segments = [];
    if (node.type === 'num') {
      // **Angepasst: Inkludiere 0 als Segment**
      segments.push({ type: 'const', value: node.value });
    }
    if (node.type === 'var') {
      if (varVals[node.name] !== 0) { // Filtere nur nicht-Null Variablen
        segments.push({ type: 'var', var: node.name, value: varVals[node.name] });
      }
    }
    if (node.type === 'op') {
      if (node.op === '+') {
        segments = segments.concat(expandNode(node.left, varVals));
        segments = segments.concat(expandNode(node.right, varVals));
      } else if (node.op === '-') {
        segments = segments.concat(expandNode(node.left, varVals));
        let rightSegments = expandNode(node.right, varVals).map(s => ({ ...s, value: -s.value }));
        segments = segments.concat(rightSegments);
      } else if (node.op === '*') {
        let left = expandNode(node.left, varVals);
        let right = expandNode(node.right, varVals);

        // Überprüfen, ob eine Seite eine einzelne Konstante ist
        if (left.length === 1 && left[0].type === 'const') {
          let multiplier = left[0].value;
          if (Number.isInteger(multiplier) && multiplier > 0) {
            segments = segments.concat(duplicateSegments(right, multiplier));
          } else {
            // Für nicht-ganze oder negative Multiplikatoren
            segments = segments.concat(right.map(s => ({ ...s, value: s.value * multiplier })));
          }
        } else if (right.length === 1 && right[0].type === 'const') {
          let multiplier = right[0].value;
          if (Number.isInteger(multiplier) && multiplier > 0) {
            segments = segments.concat(duplicateSegments(left, multiplier));
          } else {
            // Für nicht-ganze oder negative Multiplikatoren
            segments = segments.concat(left.map(s => ({ ...s, value: s.value * multiplier })));
          }
        } else {
          // Falls keine Seite eine einzelne Konstante ist, multiplizieren wir die Werte
          let leftSum = sumSegments(left);
          let rightSum = sumSegments(right);
          segments = left.map(s => ({ type: s.type, var: s.var, value: s.value * rightSum }));
        }
      }
    }
    // **Angepasst: Entferne nur Segmente mit Wert 0, außer die gesamte Seite ist 0**
    if (segments.length === 0) {
      segments.push({ type: 'const', value: 0 });
    } else {
      segments = segments.filter(s => s.value !== 0 || (s.type === 'const' && s.value === 0));
    }
    return segments;
  }

  // Aktualisierung der Streifen
  function updateStrips() {
    if (parsedEquationsList.length === 0) return;

    // Anzeige der aktuellen Gleichung
    let equationText = '';
    parsedEquationsList.forEach(eq => {
      equationText += astToString(eq.astLeft) + ' = ' + astToString(eq.astRight) + '<br>';
    });
    currentEquationText.innerHTML = equationText;

    if (parsedEquationsList.length === 1) {
      eq1LeftStrip.innerHTML = '';
      eq1RightStrip.innerHTML = '';

      // Linke Seite visualisieren
      expressionDatas[0].left.segments.forEach(s => {
        const d = document.createElement('div');
        d.classList.add('segment');
        if (s.type === 'var') d.classList.add('var');
        if (s.value < 0 && s.type === 'const') d.classList.add('negative'); // Hinzufügen der 'negative' Klasse
        if (s.value < 0 && s.type === 'var') d.classList.add('negative-var'); // Hinzufügen der 'negative-var' Klasse
        if (s.type === 'const' && s.value === 0) d.classList.add('zero'); // Hinzufügen der 'zero' Klasse
        d.textContent = (s.type === 'var') ? (s.value < 0 ? '-' + s.var : s.var) : s.value.toString(); // Anzeige des Vorzeichens bei Konstanten und Variablen
        d.style.width = `${Math.abs(s.value) * scalingFactor}px`; // Dynamische Skalierung
        eq1LeftStrip.appendChild(d);
      });

      // Rechte Seite visualisieren
      expressionDatas[0].right.segments.forEach(s => {
        const d = document.createElement('div');
        d.classList.add('segment');
        if (s.type === 'var') d.classList.add('var');
        if (s.value < 0 && s.type === 'const') d.classList.add('negative'); // Hinzufügen der 'negative' Klasse
        if (s.value < 0 && s.type === 'var') d.classList.add('negative-var'); // Hinzufügen der 'negative-var' Klasse
        if (s.type === 'const' && s.value === 0) d.classList.add('zero'); // Hinzufügen der 'zero' Klasse
        d.textContent = (s.type === 'var') ? (s.value < 0 ? '-' + s.var : s.var) : s.value.toString(); // Anzeige des Vorzeichens bei Konstanten und Variablen
        d.style.width = `${Math.abs(s.value) * scalingFactor}px`; // Dynamische Skalierung
        eq1RightStrip.appendChild(d);
      });

      makeSegmentsDraggable(eq1LeftStrip);
      makeSegmentsDraggable(eq1RightStrip);
    } else {
      eq1LeftStrip.innerHTML = '';
      eq1RightStrip.innerHTML = '';
      eq2LeftStrip.innerHTML = '';
      eq2RightStrip.innerHTML = '';

      // Gleichung 1
      expressionDatas[0].left.segments.forEach(s => {
        const d = document.createElement('div');
        d.classList.add('segment');
        if (s.type === 'var') d.classList.add('var');
        if (s.value < 0 && s.type === 'const') d.classList.add('negative'); // Hinzufügen der 'negative' Klasse
        if (s.value < 0 && s.type === 'var') d.classList.add('negative-var'); // Hinzufügen der 'negative-var' Klasse
        if (s.type === 'const' && s.value === 0) d.classList.add('zero'); // Hinzufügen der 'zero' Klasse
        d.textContent = (s.type === 'var') ? (s.value < 0 ? '-' + s.var : s.var) : s.value.toString(); // Anzeige des Vorzeichens bei Konstanten und Variablen
        d.style.width = `${Math.abs(s.value) * scalingFactor}px`;
        eq1LeftStrip.appendChild(d);
      });

      expressionDatas[0].right.segments.forEach(s => {
        const d = document.createElement('div');
        d.classList.add('segment');
        if (s.type === 'var') d.classList.add('var');
        if (s.value < 0 && s.type === 'const') d.classList.add('negative'); // Hinzufügen der 'negative' Klasse
        if (s.value < 0 && s.type === 'var') d.classList.add('negative-var'); // Hinzufügen der 'negative-var' Klasse
        if (s.type === 'const' && s.value === 0) d.classList.add('zero'); // Hinzufügen der 'zero' Klasse
        d.textContent = (s.type === 'var') ? (s.value < 0 ? '-' + s.var : s.var) : s.value.toString(); // Anzeige des Vorzeichens bei Konstanten und Variablen
        d.style.width = `${Math.abs(s.value) * scalingFactor}px`;
        eq1RightStrip.appendChild(d);
      });

      makeSegmentsDraggable(eq1LeftStrip);
      makeSegmentsDraggable(eq1RightStrip);

      // Gleichung 2
      expressionDatas[1].left.segments.forEach(s => {
        const d = document.createElement('div');
        d.classList.add('segment');
        if (s.type === 'var') d.classList.add('var');
        if (s.value < 0 && s.type === 'const') d.classList.add('negative'); // Hinzufügen der 'negative' Klasse
        if (s.value < 0 && s.type === 'var') d.classList.add('negative-var'); // Hinzufügen der 'negative-var' Klasse
        if (s.type === 'const' && s.value === 0) d.classList.add('zero'); // Hinzufügen der 'zero' Klasse
        d.textContent = (s.type === 'var') ? (s.value < 0 ? '-' + s.var : s.var) : s.value.toString(); // Anzeige des Vorzeichens bei Konstanten und Variablen
        d.style.width = `${Math.abs(s.value) * scalingFactor}px`;
        eq2LeftStrip.appendChild(d);
      });

      expressionDatas[1].right.segments.forEach(s => {
        const d = document.createElement('div');
        d.classList.add('segment');
        if (s.type === 'var') d.classList.add('var');
        if (s.value < 0 && s.type === 'const') d.classList.add('negative'); // Hinzufügen der 'negative' Klasse
        if (s.value < 0 && s.type === 'var') d.classList.add('negative-var'); // Hinzufügen der 'negative-var' Klasse
        if (s.type === 'const' && s.value === 0) d.classList.add('zero'); // Hinzufügen der 'zero' Klasse
        d.textContent = (s.type === 'var') ? (s.value < 0 ? '-' + s.var : s.var) : s.value.toString(); // Anzeige des Vorzeichens bei Konstanten und Variablen
        d.style.width = `${Math.abs(s.value) * scalingFactor}px`;
        eq2RightStrip.appendChild(d);
      });

      makeSegmentsDraggable(eq2LeftStrip);
      makeSegmentsDraggable(eq2RightStrip);
    }
  }

  // Hilfsfunktion zur Umwandlung des AST in einen String
  function astToString(node) {
    if (node.type === 'num') return node.value.toString();
    if (node.type === 'var') return node.name;
    if (node.type === 'op') {
      let left = astToString(node.left);
      let right = astToString(node.right);
      return `(${left} ${node.op} ${right})`;
    }
    return '';
  }

  // Funktion zur Aktualisierung der Anzeige der aktuellen Gleichung
  function updateCurrentEquation() {
    let equationText = '';
    parsedEquationsList.forEach(eq => {
      equationText += astToString(eq.astLeft) + ' = ' + astToString(eq.astRight) + '<br>';
    });
    currentEquationText.innerHTML = equationText;
  }

  // Event Listener für den Hinweis-Button
  hintButton.addEventListener('click', () => {
    if (currentEquationDiv.style.display === 'none' || currentEquationDiv.style.display === '') {
      currentEquationDiv.style.display = 'block';
      hintButton.textContent = 'Hinweis verbergen';
    } else {
      currentEquationDiv.style.display = 'none';
      hintButton.textContent = 'Hinweis anzeigen';
    }
  });

  // Tabs klickbar
  document.querySelectorAll('nav a[data-tab]').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      document.querySelectorAll('nav a[data-tab]').forEach(l => l.classList.remove('active'));
      link.classList.add('active');
      const tab = link.getAttribute('data-tab');
      document.querySelectorAll('.tab-content').forEach(sec => {
        if (sec.id === tab) sec.classList.remove('hidden');
        else sec.classList.add('hidden');
      });
      if (tab === 'home') {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    });
  });

  // Akkordeon klickbar
  document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
      const target = header.getAttribute('data-target');
      const content = document.getElementById(target);
      if (content.style.display === 'block') {
        content.style.display = 'none';
      } else {
        // Schließe andere geöffnete Akkordeons
        document.querySelectorAll('.accordion-content').forEach(sec => sec.style.display = 'none');
        content.style.display = 'block';
      }
    });
  });

  // Resize Event Listener mit Debouncing
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      calculateScalingFactor();
      updateStrips();
    }, 200); // Verzögerung von 200ms
  });

});
</script>
</body>
</html>
